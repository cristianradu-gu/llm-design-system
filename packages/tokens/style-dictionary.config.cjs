/* eslint-disable no-console */
const fs = require("node:fs");
const path = require("node:path");

/**
 * We intentionally build theme-specific CSS files and then stitch them together
 * into a single `variables.css` entrypoint. This keeps consumption simple while
 * still allowing `data-theme="light|dark"` switching.
 */

let didRegisterFormats = false;

async function getStyleDictionary() {
  // style-dictionary v4 is ESM. In CJS, we must use dynamic import.
  const mod = await import("style-dictionary");
  return mod.default;
}

async function ensureFormatsRegistered(StyleDictionary) {
  if (didRegisterFormats) return;
  didRegisterFormats = true;

  StyleDictionary.registerFormat({
    name: "acme/css-variables-selector",
    format: ({ dictionary, options }) => {
      const selector = options?.selector ?? ":root";
      const header = `/* Generated by Style Dictionary (acme) */\n${selector} {\n`;
      const body = dictionary.allTokens
        // In Style Dictionary v4 with DTCG/W3C-style tokens, resolved values live on `$value`.
        .map((token) => `  --${token.name}: ${token.$value ?? token.value};`)
        .join("\n");
      const footer = "\n}\n";
      return header + body + footer;
    }
  });
}

async function buildThemeCss({ themeName, sources, selector, outFile }) {
  const StyleDictionary = await getStyleDictionary();
  await ensureFormatsRegistered(StyleDictionary);

  const sd = new StyleDictionary({
    source: sources,
    platforms: {
      css: {
        transformGroup: "css",
        buildPath: "dist/css/",
        files: [
          {
            destination: outFile,
            format: "acme/css-variables-selector",
            options: { selector }
          }
        ]
      }
    }
  });

  console.log(`[tokens] building CSS for theme="${themeName}" -> dist/css/${outFile}`);
  await sd.buildAllPlatforms();
  return sd;
}

function writeFile(filePath, contents) {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
  fs.writeFileSync(filePath, contents, "utf8");
}

async function main() {
  const root = process.cwd();
  const sourcesBase = [
    path.join(root, "tokens/core.json"),
    path.join(root, "tokens/semantic.json")
  ];

  await buildThemeCss({
    themeName: "light",
    sources: [...sourcesBase, path.join(root, "themes/light.json")],
    selector: ":root[data-theme='light']",
    outFile: "light.css"
  });

  const darkSd = await buildThemeCss({
    themeName: "dark",
    sources: [...sourcesBase, path.join(root, "themes/dark.json")],
    selector: ":root[data-theme='dark']",
    outFile: "dark.css"
  });

  // Combined entrypoint for consumers (Tailwind base layer loads this once).
  const variablesCss = `/* Generated by Style Dictionary (acme) */\n@import \"./light.css\";\n@import \"./dark.css\";\n`;
  writeFile(path.join(root, "dist/css/variables.css"), variablesCss);

  // Lightweight JS+types export: var() references keyed by CSS custom property name.
  // We use the dark dictionary because it includes the full token set; keys are identical.
  const cssDictionary = await darkSd.getPlatformTokens("css");
  const varNames = cssDictionary.allTokens.map((t) => t.name).sort();

  const varsObjectEntries = varNames
    .map((name) => `  "${name}": "var(--${name})"`)
    .join(",\n");

  const jsOut = `// Generated by Style Dictionary (acme)\nexport const themes = [\"light\", \"dark\"];\nexport const vars = {\n${varsObjectEntries}\n};\n`;
  writeFile(path.join(root, "dist/ts/tokens.js"), jsOut);

  const dtsOut =
    `// Generated by Style Dictionary (acme)\n` +
    `export declare const themes: readonly [\"light\", \"dark\"];` +
    `\nexport declare const vars: Record<string, string>;\n`;
  writeFile(path.join(root, "dist/ts/tokens.d.ts"), dtsOut);

  console.log("[tokens] wrote dist/css/variables.css and dist/ts/tokens.(js|d.ts)");
}

main();


